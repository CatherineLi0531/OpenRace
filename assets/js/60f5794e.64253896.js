(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{161:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/PTA-Overview-df6d2d0f826fcc2817f04691e406dcf2.svg"},82:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return p}));var a=n(3),i=n(7),r=(n(0),n(92)),o={id:"doc-pta-arch",title:"Pointer Analysis Architecture"},c={unversionedId:"doc-pta-arch",id:"doc-pta-arch",isDocsHomePage:!1,title:"Pointer Analysis Architecture",description:"Overview",source:"@site/docs/doc-pta-arch.md",sourceDirName:".",slug:"/doc-pta-arch",permalink:"/OpenRace/doc-pta-arch",editUrl:"https://github.com/coderrect-inc/OpenRace/tree/develop/website/docs/doc-pta-arch.md",version:"current",frontMatter:{id:"doc-pta-arch",title:"Pointer Analysis Architecture"},sidebar:"openraceSidebar",previous:{title:"Contribute to Docs",permalink:"/OpenRace/doc-contribute-to-docs"}},l=[{value:"Overview",id:"overview",children:[]},{value:"High-Level Architecture",id:"high-level-architecture",children:[{value:"Detailed Implementation",id:"detailed-implementation",children:[]},{value:"Field-Sensitivity",id:"field-sensitivity",children:[]}]},{value:"Heuristics",id:"heuristics",children:[{value:"User-Specified Heuristics",id:"user-specified-heuristics",children:[]},{value:"Reserved Heuristics",id:"reserved-heuristics",children:[]},{value:"Removed Heuristics",id:"removed-heuristics",children:[]}]}],s={toc:l};function p(e){var t=e.components,o=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},s,o,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"overview"},"Overview"),Object(r.b)("p",null,"The Pointer Analysis framework (under ",Object(r.b)("inlineCode",{parentName:"p"},"src/PointerAnalysis"),") in OpenRace\ncomputes a set of object (",Object(r.b)("em",{parentName:"p"},"points-to set"),") that can be pointed by a pointer\nin the program during the runtime.\nIt implements a context-sensitive and field-sensitive inclusion-based (Andersen)\nPointer Analysis algorithm.  "),Object(r.b)("h2",{id:"high-level-architecture"},"High-Level Architecture"),Object(r.b)("p",null,"There are three major components in the pointer analysis framework and they\ninteract with each other to compute the final result."),Object(r.b)("p",null,Object(r.b)("img",{alt:"PTA-arch",src:n(161).default})),Object(r.b)("p",null,"These components communicated with each other through a set of pre-defined APIs in\n",Object(r.b)("inlineCode",{parentName:"p"},"MemModelTrait")," as well as in ",Object(r.b)("inlineCode",{parentName:"p"},"LangModelTrait"),".\nAt high level,\n",Object(r.b)("strong",{parentName:"p"},"Language Model")," abstracts the target program into the ",Object(r.b)("em",{parentName:"p"},"constraint graph"),",\nthe pointer analysis framework offers the flexibility for user-defined language model to\nintercept any function call in the program and handle it differently;\n",Object(r.b)("strong",{parentName:"p"},"Memory Model")," handles the creation of the static objects, different memory models handles\nobject creation differently. E.g., Field-Insensitive Memory Model (",Object(r.b)("inlineCode",{parentName:"p"},"FIMemModel.h"),") simply\ncreates one object node for the object while Field-Sensitive Memory Model (",Object(r.b)("inlineCode",{parentName:"p"},"FSMemModel.h"),")\ncreates one object node for each field of the object.\nFinally, ",Object(r.b)("strong",{parentName:"p"},"Solver")," takes the constraint graph as the input and computes the final result."),Object(r.b)("h3",{id:"detailed-implementation"},"Detailed Implementation"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("strong",{parentName:"li"},"Language Model"),": Language Model transfers the program into the constraint graph/pointer assignment graph.",Object(r.b)("br",{parentName:"li"}),"It creates pointer nodes (corresponding pointers in the program) and links nodes with different kinds of edges (corresponding to different operations performed in the program). There are five different kinds of edges in the constraint graph.")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cpp"},"enum class Constraints : std::uint8_t {\n    load, store, copy, addr_of, offset,\n};\n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"load edge: ",Object(r.b)("inlineCode",{parentName:"li"},"if ptr1 = *ptr2;, then ptr2 --load--\x3e ptr1")," (ptr2 is loaded into ptr1)."),Object(r.b)("li",{parentName:"ul"},"store edge: ",Object(r.b)("inlineCode",{parentName:"li"},"if *ptr1 = ptr2;, then ptr2 --store--\x3e ptr1")," (ptr2 is stored into ptr1)."),Object(r.b)("li",{parentName:"ul"},"copy edge: ",Object(r.b)("inlineCode",{parentName:"li"},"if ptr1 = ptr2;, then ptr2 --copy--\x3e ptr1")," (ptr2 is copied to ptr1)."),Object(r.b)("li",{parentName:"ul"},"addr_of edge: ",Object(r.b)("inlineCode",{parentName:"li"},"if ptr1 = &ptr2; , then ptr2--addr_of--\x3e ptr1")," (ptr1 takes the address of ptr2)"),Object(r.b)("li",{parentName:"ul"},"offset edge: ",Object(r.b)("inlineCode",{parentName:"li"},"if ptr1 = ptr2->f;, then ptr2--offset--\x3eptr1")," (ptr1 add a offset to ptr2).")),Object(r.b)("ol",{start:2},Object(r.b)("li",{parentName:"ol"},Object(r.b)("strong",{parentName:"li"},"Memory Model"),": Memory Model models the objects allocated in the program.\nFor example, it computes the size of each object, the memory layout of each object and it creates object nodes in the Constraint Graph.",Object(r.b)("br",{parentName:"li"}),"Currently, we have two different memory models: ")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"Field-insensitive memory model"),": Field-insensitive memory model is a simple implementation of the memory model. It is relatively fast but also inaccurate. The field-insensitive memory model does not distinguish different fields of the object. For the following code snippet:")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cpp"},"struct A {\n  int a,\n  int b,\n} obj;\n\nint *ptr1 = &obj.a;\nint *ptr2 = &obj.b;\n\n// ptr1 and ptr2 are considered as alias when using field-insensitive memory\n// model, even though they point to different fields of the object.\nALIAS(ptr1, ptr2) == true \n")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("em",{parentName:"li"},"Field-sensitive memory model"),": Field-sensitive memory model (still in process) overcomes the limitations of the field-insensitive memory model. It distinguishes different fields of the same object so that the ptr1 and ptr2 in the above example are not considered as aliases. It computes the memory layout (the offset of each field)  and provides APIs to index into the complicated object to access the right fields.")),Object(r.b)("ol",{start:3},Object(r.b)("li",{parentName:"ol"},Object(r.b)("strong",{parentName:"li"},"Andersen Solver"),": After the language model builds the constraint graph and memory model models the object, the pointer analysis uses the solver to computes the points-to set of the pointer. The detailed description of the algorithm can be found via ",Object(r.b)("a",{parentName:"li",href:"http://compilers.cs.ucla.edu/fernando/publications/papers/CGO09.pdf"},"http://compilers.cs.ucla.edu/fernando/publications/papers/CGO09.pdf"),".")),Object(r.b)("h3",{id:"field-sensitivity"},"Field-Sensitivity"),Object(r.b)("p",null,"Since the implementation of Field Sensitivity is complex, We provide some additional information in the documentation."),Object(r.b)("p",null,"Field-sensitive pointer analysis is achieved by handling the offset constraints in the above table, at a high level,\nthe constraint ",Object(r.b)("inlineCode",{parentName:"p"},"v <- &s.field")," is satisfied by first index the object ",Object(r.b)("inlineCode",{parentName:"p"},"s.field")," and then add the address of ",Object(r.b)("inlineCode",{parentName:"p"},"s.field")," to the ",Object(r.b)("inlineCode",{parentName:"p"},"pts(v)"),".\n",Object(r.b)("inlineCode",{parentName:"p"},"SolverBase.h: processOffset")," implements the functionality."),Object(r.b)("p",null,"For efficiency, the processOffset function maintains a cache (handledGEPMap) for GEP instructions to only handled diffed object indexing that haven\u2019t been handled before.",Object(r.b)("br",{parentName:"p"}),"\n","The diffed object indexing is implementation as below:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cpp"},"PtsTy &handled = handledGEPMap.try_emplace(ptrNode).first->second;\nconst PtsTy &curPts = PT::getPointsTo(src->getNodeID());\n\nPtsTy newGEPs;\nnewGEPs.intersectWithComplement(curPts, handled); // set intersect with complement\n")),Object(r.b)("p",null,"After the diffed points-to set is computed,  it iterate over the set using the following loop."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cpp"}," for (auto objNode : nodeVec) {\n      // this might create new object, thus modify the points-to set\n      auto *fieldObj = llvm::cast_or_null<ObjNodeTy>(LMT::indexObject(this->getLangModel(), objNode, gep));\n      if (fieldObj == nullptr) {\n           continue;\n      }\n\n      if (!PT::has(ptrNode->getNodeID(), fieldObj->getObjectID())) {\n           this->consGraph->addConstraints(fieldObj, ptrNode, Constraints::addr_of);\n           callBack(fieldObj, ptrNode);\n           changed = true;\n      }\n  }\n")),Object(r.b)("p",null,"The fieldObject is computed by statement ",Object(r.b)("inlineCode",{parentName:"p"},"LMT::indexObject(this->getLangModel(), objNode, gep)")," which index the object."),Object(r.b)("p",null,"The indexObject method is implemented differently when using different memory model, in FSMemModel, the code is available in ",Object(r.b)("inlineCode",{parentName:"p"},"FSMemModel::indexObject()"),"\nWe implemented a different scheme than the traditional field-sensitive pointer analysis for C/C++ which uses logic field index to index the object.\nOur implementation instead uses physical layout offset to index objects."),Object(r.b)("p",null,"At a high level, FSMemModel computes a MemLayout for different types.\nFor example, suppose ",Object(r.b)("inlineCode",{parentName:"p"},"sizeof(double *) == 4"),", the memory layout for the following structure is a bitvector and is computed as below:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cpp"},"struct inner {\n    double *b;\n    double *c;\n};\nstruct outter {\n    struct inner array_inner[10];\n    double*  d;\n};\n")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"// memory layout\n|1000 1000| 1000\n|--array--| // mark the first 8 bytes (corresponding to array_inner) as array\n")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"FSMemModel::indexObject()")," method indices the memory layout to test whether the bit is set in the memory layout and return the corresponding object at the offset as following"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-cpp"},"auto offset = llvm::APInt(DL.getIndexTypeSizeInBits(gep->getType()), 0);\ngep->accumulateConstantOffset(DL, offset);\n\nauto result = obj->memBlock->getObjectAt(obj->pOffset + offset.getSExtValue());\n")),Object(r.b)("p",null,"It first use accumulate the offset of the gep by ",Object(r.b)("inlineCode",{parentName:"p"},"gep->accumulateConstantOffset(DL, offset)")," and then it index the object\nusing auto ",Object(r.b)("inlineCode",{parentName:"p"},"result = obj->memBlock->getObjectAt(obj->pOffset + offset.getSExtValue())"),".\nIf the supplied physical offset is invalid (can not be indexed), it returns ",Object(r.b)("inlineCode",{parentName:"p"},"nullptr"),"."),Object(r.b)("h2",{id:"heuristics"},"Heuristics"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Will update whenever heuristics are discovered.")),Object(r.b)("p",null,"We explain our heuristic code in our pointer analysis in this section. Some heuristic decisions are removed, some are left to users to specify the desired values,\nand others are reserved in our code base."),Object(r.b)("h3",{id:"user-specified-heuristics"},"User-Specified Heuristics"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"INDIRECT_OPTION"),": Whether and how to add the resolved indirect function calls to the callgraph"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"There are three options:"),Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",{parentName:"pre",className:"language-cpp"},"enum class IndirectResolveOption {\n  SKIP,        // Do not add the resolved function to the callgraph\n  WITH_LIMIT,  // Only add the resolved function to the callgraph iff the indirect call limit is not exceeded.\n  CRITICAL,    // Make sure the function are inserted to callgraph, even if the limit has been exceeded.\n}; \n")),Object(r.b)("p",{parentName:"li"},"For the usage of ",Object(r.b)("inlineCode",{parentName:"p"},"WITH_LIMIT"),", the limit is defined by variable ",Object(r.b)("inlineCode",{parentName:"p"},"Max_Indirect_Target"),".")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Default value: "),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"INDIRECT_OPTION = IndirectResolveOption::WITH_LIMIT")," and ",Object(r.b)("inlineCode",{parentName:"li"},"Max_Indirect_Target = 999")))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Specified by user since commit ",Object(r.b)("a",{parentName:"p",href:"https://github.com/coderrect-inc/OpenRace/commit/5c766da289c3b8cc1ba2df56ab8b0207a4bfc74e"},"5c766da289c3b8cc1ba2df56ab8b0207a4bfc74e"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"How to specify: for example, if choosing ",Object(r.b)("inlineCode",{parentName:"p"},"SKIP"),":"),Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",{parentName:"pre",className:"language-cpp"},"openrace -INDIRECT_OPTION=SKIP pthread-simple.ll\n")),Object(r.b)("p",{parentName:"li"},"if choosing 'WITH_LIMIT':"),Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",{parentName:"pre",className:"language-cpp"},"openrace -INDIRECT_OPTION=WITH_LIMIT -Max_Indirect_Target=1028 pthread-simple.ll\n"))))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ANON_REC_LIMIT"),": Set the upperbound of the total size of recursively-created anonymous objects in a program"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"Default value: 999"),Object(r.b)("li",{parentName:"ul"},"Specified by user since commit ",Object(r.b)("a",{parentName:"li",href:"https://github.com/coderrect-inc/OpenRace/commit/cf77af58709374a7ff5d8237bc0f9361d4b270e0"},"cf77af58709374a7ff5d8237bc0f9361d4b270e0")),Object(r.b)("li",{parentName:"ul"},"How to specify: for example,",Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",{parentName:"pre",className:"language-cpp"},"openrace -ANON_REC_LIMIT=10 pthread-simple.ll\n"))))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},Object(r.b)("inlineCode",{parentName:"p"},"ANON_REC_DEPTH_LIMIT"),": Set the upperbound of the depth of types considered for a recursively-created anonymous object in a program"),Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"Default value: 10"),Object(r.b)("li",{parentName:"ul"},"Specified by user since commit ",Object(r.b)("a",{parentName:"li",href:"https://github.com/coderrect-inc/OpenRace/commit/cf77af58709374a7ff5d8237bc0f9361d4b270e0"},"cf77af58709374a7ff5d8237bc0f9361d4b270e0")),Object(r.b)("li",{parentName:"ul"},"How to specify: for example,",Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",{parentName:"pre",className:"language-cpp"},"openrace -ANON_REC_DEPTH_LIMIT=5 pthread-simple.ll\n")))))),Object(r.b)("h3",{id:"reserved-heuristics"},"Reserved Heuristics"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"HASH_EDGE_LIMIT"),": Define the size of ",Object(r.b)("a",{parentName:"li",href:"https://github.com/coderrect-inc/OpenRace/blob/6bd1e181e02cff77e27c43dc92f6fc6748fe25fe/src/PointerAnalysis/Solver/PartialUpdateSolver.h#L163"},Object(r.b)("inlineCode",{parentName:"a"},"requiredEdges")),"\n(of type ",Object(r.b)("inlineCode",{parentName:"li"},"llvm::BitVector"),") which indexes the newly added copy edges by using the hash values of the two nodes involved in a copy edge.\nThe maximum value of the hash value is 4,294,967,295 (as indicated by ",Object(r.b)("inlineCode",{parentName:"li"},"size_t"),", a.k.a., ",Object(r.b)("inlineCode",{parentName:"li"},"unsigned long int"),").\nAs shown ",Object(r.b)("a",{parentName:"li",href:"https://github.com/coderrect-inc/OpenRace/blob/6bd1e181e02cff77e27c43dc92f6fc6748fe25fe/src/PointerAnalysis/Solver/PartialUpdateSolver.h#L168"},"here"),",\nin order to save memory and improve performance, and also the size of newly added copy edges is limited for every iteration,\nwe use ",Object(r.b)("inlineCode",{parentName:"li"},"HASH_EDGE_LIMIT")," as the size for ",Object(r.b)("inlineCode",{parentName:"li"},"requiredEdges")," instead of the max value.",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"Default value: 1000032953")))),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"The array heap allocation types might be inferred using heuristics",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"The ",Object(r.b)("a",{parentName:"p",href:"https://github.com/coderrect-inc/OpenRace/blob/9e5a85296a4d3ef65bdeb4ce8ddb48d4e874d156/src/PointerAnalysis/Util/Util.cpp#L454"},"assumption")," here is:"),Object(r.b)("p",{parentName:"li"},Object(r.b)("em",{parentName:"p"},"if the last element of the allocated structure is a zero-sized array, it is a structure type with flexible array element."))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"Mainly used in functions ",Object(r.b)("a",{parentName:"p",href:"https://github.com/coderrect-inc/OpenRace/blob/9e5a85296a4d3ef65bdeb4ce8ddb48d4e874d156/src/PointerAnalysis/Util/Util.cpp#L442"},Object(r.b)("inlineCode",{parentName:"a"},"isStructWithFlexibleArray()")),"\nand ",Object(r.b)("a",{parentName:"p",href:"https://github.com/coderrect-inc/OpenRace/blob/80ea16167e5eae99f712ee191c5cea1f52280f45/src/PointerAnalysis/Models/MemoryModel/FieldSensitive/FSMemModel.h#L102-L110"},Object(r.b)("inlineCode",{parentName:"a"},"allocStructArrayObjImpl()"))))))),Object(r.b)("h3",{id:"removed-heuristics"},"Removed Heuristics"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"PTS_SIZE_LIMIT"),": Set the upperbound of the size of a points-to set",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"Default value: 999"),Object(r.b)("li",{parentName:"ul"},"Removed since commit ",Object(r.b)("a",{parentName:"li",href:"https://github.com/coderrect-inc/OpenRace/commit/0113a0adda3bf00f50c72470f95ee6c4a8feb2cb"},"0113a0adda3bf00f50c72470f95ee6c4a8feb2cb"))))))}p.isMDXComponent=!0},92:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return u}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=i.a.createContext({}),p=function(e){var t=i.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},b=function(e){var t=p(e.components);return i.a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},m=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),b=p(n),m=a,u=b["".concat(o,".").concat(m)]||b[m]||d[m]||r;return n?i.a.createElement(u,c(c({ref:t},s),{},{components:n})):i.a.createElement(u,c({ref:t},s))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=m;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:a,o[1]=c;for(var s=2;s<r;s++)o[s]=n[s];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);