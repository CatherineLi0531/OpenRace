(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{161:function(e,t,n){"use strict";n.r(t),t.default=n.p+"assets/images/PTA-Overview-df6d2d0f826fcc2817f04691e406dcf2.svg"},82:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return a})),n.d(t,"metadata",(function(){return l})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return p}));var i=n(3),r=n(7),o=(n(0),n(92)),a={id:"doc-pta-arch",title:"Pointer Analysis Architecture"},l={unversionedId:"doc-pta-arch",id:"doc-pta-arch",isDocsHomePage:!1,title:"Pointer Analysis Architecture",description:"Overview",source:"@site/docs/doc-pta-arch.md",sourceDirName:".",slug:"/doc-pta-arch",permalink:"/OpenRace/doc-pta-arch",editUrl:"https://github.com/coderrect-inc/OpenRace/tree/develop/website/docs/doc-pta-arch.md",version:"current",frontMatter:{id:"doc-pta-arch",title:"Pointer Analysis Architecture"},sidebar:"openraceSidebar",previous:{title:"Contribute to Docs",permalink:"/OpenRace/doc-contribute-to-docs"}},c=[{value:"Overview",id:"overview",children:[]},{value:"High-Level Architecture",id:"high-level-architecture",children:[{value:"Detailed Implementation",id:"detailed-implementation",children:[]},{value:"Field-Sensitivity",id:"field-sensitivity",children:[]}]}],s={toc:c};function p(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(i.a)({},s,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"overview"},"Overview"),Object(o.b)("p",null,"The Pointer Analysis framework (under ",Object(o.b)("inlineCode",{parentName:"p"},"src/PointerAnalysis"),") in OpenRace\ncomputes a set of object (",Object(o.b)("em",{parentName:"p"},"points-to set"),") that can be pointed by a pointer\nin the program during the runtime.\nIt implements a context-sensitive and field-sensitive inclusion-based (Andersen)\nPointer Analysis algorithm.  "),Object(o.b)("h2",{id:"high-level-architecture"},"High-Level Architecture"),Object(o.b)("p",null,"There are three major components in the pointer analysis framework and they\ninteract with each other to compute the final result."),Object(o.b)("p",null,Object(o.b)("img",{alt:"PTA-arch",src:n(161).default})),Object(o.b)("p",null,"These components communicated with each other through a set of pre-defined APIs in\n",Object(o.b)("inlineCode",{parentName:"p"},"MemModelTrait")," as well as in ",Object(o.b)("inlineCode",{parentName:"p"},"LangModelTrait"),".\nAt high level,\n",Object(o.b)("strong",{parentName:"p"},"Language Model")," abstracts the target program into the ",Object(o.b)("em",{parentName:"p"},"constraint graph"),",\nthe pointer analysis framework offers the flexibility for user-defined language model to\nintercept any function call in the program and handle it differently;\n",Object(o.b)("strong",{parentName:"p"},"Memory Model")," handles the creation of the static objects, different memory models handles\nobject creation differently. E.g., Field-Insensitive Memory Model (",Object(o.b)("inlineCode",{parentName:"p"},"FIMemModel.h"),") simply\ncreates one object node for the object while Field-Sensitive Memory Model (",Object(o.b)("inlineCode",{parentName:"p"},"FSMemModel.h"),")\ncreates one object node for each field of the object.\nFinally, ",Object(o.b)("strong",{parentName:"p"},"Solver")," takes the constraint graph as the input and computes the final result."),Object(o.b)("h3",{id:"detailed-implementation"},"Detailed Implementation"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},Object(o.b)("strong",{parentName:"li"},"Language Model"),": Language Model transfers the program into the constraint graph/pointer assignment graph.",Object(o.b)("br",{parentName:"li"}),"It creates pointer nodes (corresponding pointers in the program) and links nodes with different kinds of edges (corresponding to different operations performed in the program). There are five different kinds of edges in the constraint graph.")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-cpp"},"enum class Constraints : std::uint8_t {\n    load, store, copy, addr_of, offset,\n};\n")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"load edge: ",Object(o.b)("inlineCode",{parentName:"li"},"if ptr1 = *ptr2;, then ptr2 --load--\x3e ptr1")," (ptr2 is loaded into ptr1)."),Object(o.b)("li",{parentName:"ul"},"store edge: ",Object(o.b)("inlineCode",{parentName:"li"},"if *ptr1 = ptr2;, then ptr2 --store--\x3e ptr1")," (ptr2 is stored into ptr1)."),Object(o.b)("li",{parentName:"ul"},"copy edge: ",Object(o.b)("inlineCode",{parentName:"li"},"if ptr1 = ptr2;, then ptr2 --copy--\x3e ptr1")," (ptr2 is copied to ptr1)."),Object(o.b)("li",{parentName:"ul"},"addr_of edge: ",Object(o.b)("inlineCode",{parentName:"li"},"if ptr1 = &ptr2; , then ptr2--addr_of--\x3e ptr1")," (ptr1 takes the address of ptr2)"),Object(o.b)("li",{parentName:"ul"},"offset edge: ",Object(o.b)("inlineCode",{parentName:"li"},"if ptr1 = ptr2->f;, then ptr2--offset--\x3eptr1")," (ptr1 add a offset to ptr2).")),Object(o.b)("ol",{start:2},Object(o.b)("li",{parentName:"ol"},Object(o.b)("strong",{parentName:"li"},"Memory Model"),": Memory Model models the objects allocated in the program.\nFor example, it computes the size of each object, the memory layout of each object and it creates object nodes in the Constraint Graph.",Object(o.b)("br",{parentName:"li"}),"Currently, we have two different memory models: ")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("em",{parentName:"li"},"Field-insensitive memory model"),": Field-insensitive memory model is a simple implementation of the memory model. It is relatively fast but also inaccurate. The field-insensitive memory model does not distinguish different fields of the object. For the following code snippet:")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-cpp"},"struct A {\n  int a,\n  int b,\n} obj;\n\nint *ptr1 = &obj.a;\nint *ptr2 = &obj.b;\n\n// ptr1 and ptr2 are considered as alias when using field-insensitive memory\n// model, even though they point to different fields of the object.\nALIAS(ptr1, ptr2) == true \n")),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("em",{parentName:"li"},"Field-sensitive memory model"),": Field-sensitive memory model (still in process) overcomes the limitations of the field-insensitive memory model. It distinguishes different fields of the same object so that the ptr1 and ptr2 in the above example are not considered as aliases. It computes the memory layout (the offset of each field)  and provides APIs to index into the complicated object to access the right fields.")),Object(o.b)("ol",{start:3},Object(o.b)("li",{parentName:"ol"},Object(o.b)("strong",{parentName:"li"},"Andersen Solver"),": After the language model builds the constraint graph and memory model models the object, the pointer analysis uses the solver to computes the points-to set of the pointer. The detailed description of the algorithm can be found via ",Object(o.b)("a",{parentName:"li",href:"http://compilers.cs.ucla.edu/fernando/publications/papers/CGO09.pdf"},"http://compilers.cs.ucla.edu/fernando/publications/papers/CGO09.pdf"),".")),Object(o.b)("h3",{id:"field-sensitivity"},"Field-Sensitivity"),Object(o.b)("p",null,"Since the implementation of Field Sensitivity is complex, We provide some additional information in the documentation."),Object(o.b)("p",null,"Field-sensitive pointer analysis is achieved by handling the offset constraints in the above table, at a high level,\nthe constraint ",Object(o.b)("inlineCode",{parentName:"p"},"v <- &s.field")," is satisfied by first index the object ",Object(o.b)("inlineCode",{parentName:"p"},"s.field")," and then add the address of ",Object(o.b)("inlineCode",{parentName:"p"},"s.field")," to the ",Object(o.b)("inlineCode",{parentName:"p"},"pts(v)"),".\n",Object(o.b)("inlineCode",{parentName:"p"},"SolverBase.h: processOffset")," implements the functionality."),Object(o.b)("p",null,"For efficiency, the processOffset function maintains a cache (handledGEPMap) for GEP instructions to only handled diffed object indexing that haven\u2019t been handled before.",Object(o.b)("br",{parentName:"p"}),"\n","The diffed object indexing is implementation as below:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-cpp"},"PtsTy &handled = handledGEPMap.try_emplace(ptrNode).first->second;\nconst PtsTy &curPts = PT::getPointsTo(src->getNodeID());\n\nPtsTy newGEPs;\nnewGEPs.intersectWithComplement(curPts, handled); // set intersect with complement\n")),Object(o.b)("p",null,"After the diffed points-to set is computed,  it iterate over the set using the following loop."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-cpp"}," for (auto objNode : nodeVec) {\n      // this might create new object, thus modify the points-to set\n      auto *fieldObj = llvm::cast_or_null<ObjNodeTy>(LMT::indexObject(this->getLangModel(), objNode, gep));\n      if (fieldObj == nullptr) {\n           continue;\n      }\n\n      if (!PT::has(ptrNode->getNodeID(), fieldObj->getObjectID())) {\n           this->consGraph->addConstraints(fieldObj, ptrNode, Constraints::addr_of);\n           callBack(fieldObj, ptrNode);\n           changed = true;\n      }\n  }\n")),Object(o.b)("p",null,"The fieldObject is computed by statement ",Object(o.b)("inlineCode",{parentName:"p"},"LMT::indexObject(this->getLangModel(), objNode, gep)")," which index the object."),Object(o.b)("p",null,"The indexObject method is implemented differently when using different memory model, in FSMemModel, the code is available in ",Object(o.b)("inlineCode",{parentName:"p"},"FSMemModel::indexObject()"),"\nWe implemented a different scheme than the traditional field-sensitive pointer analysis for C/C++ which uses logic field index to index the object.\nOur implementation instead uses physical layout offset to index objects."),Object(o.b)("p",null,"At a high level, FSMemModel computes a MemLayout for different types.\nFor example, suppose ",Object(o.b)("inlineCode",{parentName:"p"},"sizeof(double *) == 4"),", the memory layout for the following structure is a bitvector and is computed as below:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-cpp"},"struct inner {\n    double *b;\n    double *c;\n};\nstruct outter {\n    struct inner array_inner[10];\n    double*  d;\n};\n")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre"},"// memory layout\n|1000 1000| 1000\n|--array--| // mark the first 8 bytes (corresponding to array_inner) as array\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"FSMemModel::indexObject()")," method indices the memory layout to test whether the bit is set in the memory layout and return the corresponding object at the offset as following"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-cpp"},"auto offset = llvm::APInt(DL.getIndexTypeSizeInBits(gep->getType()), 0);\ngep->accumulateConstantOffset(DL, offset);\n\nauto result = obj->memBlock->getObjectAt(obj->pOffset + offset.getSExtValue());\n")),Object(o.b)("p",null,"It first use accumulate the offset of the gep by ",Object(o.b)("inlineCode",{parentName:"p"},"gep->accumulateConstantOffset(DL, offset)")," and then it index the object\nusing auto ",Object(o.b)("inlineCode",{parentName:"p"},"result = obj->memBlock->getObjectAt(obj->pOffset + offset.getSExtValue())"),".\nIf the supplied physical offset is invalid (can not be indexed), it returns ",Object(o.b)("inlineCode",{parentName:"p"},"nullptr"),"."))}p.isMDXComponent=!0},92:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return f}));var i=n(0),r=n.n(i);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=r.a.createContext({}),p=function(e){var t=r.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return r.a.createElement(s.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},m=r.a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,a=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),d=p(n),m=i,f=d["".concat(a,".").concat(m)]||d[m]||b[m]||o;return n?r.a.createElement(f,l(l({ref:t},s),{},{components:n})):r.a.createElement(f,l({ref:t},s))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=m;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:i,a[1]=l;for(var s=2;s<o;s++)a[s]=n[s];return r.a.createElement.apply(null,a)}return r.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);