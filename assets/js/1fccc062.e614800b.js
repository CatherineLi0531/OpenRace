(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{78:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return l})),n.d(t,"toc",(function(){return i})),n.d(t,"default",(function(){return s}));var r=n(3),a=n(7),o=(n(0),n(92)),c={id:"doc-get-started",title:"Get Started with Coderrect OpenRace",slug:"/"},l={unversionedId:"doc-get-started",id:"doc-get-started",isDocsHomePage:!1,title:"Get Started with Coderrect OpenRace",description:"OpenRace is an in-development C/C++ data race detection tool.",source:"@site/docs/doc-get-started.md",sourceDirName:".",slug:"/",permalink:"/OpenRace/",editUrl:"https://github.com/coderrect-inc/OpenRace/tree/develop/website/docs/doc-get-started.md",version:"current",frontMatter:{id:"doc-get-started",title:"Get Started with Coderrect OpenRace",slug:"/"},sidebar:"openraceSidebar",next:{title:"Setting Up Dev Environment",permalink:"/OpenRace/doc-setup-dev-env"}},i=[],p={toc:i};function s(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"OpenRace is an in-development C/C++ data race detection tool."),Object(o.b)("p",null,"This project aims to have a clean and extensible design to facilitate community contributions."),Object(o.b)("p",null,"OpenRace is an open source implementation of the ",Object(o.b)("a",{parentName:"p",href:"https://coderrect.com/overview/"},"Coderrect Scanner")," which is a C/C++/Fortran data race detection tool. The open source tool is currently behind the original scanner in terms of feature support, but we are actively developing and expect OpenRace to eventually replace the closed source implementation of ",Object(o.b)("a",{parentName:"p",href:"https://coderrect.com/overview/"},"Coderrect Scanner"),"."),Object(o.b)("p",null,Object(o.b)("a",{parentName:"p",href:"https://github.com/coderrect-inc/OpenRace/actions/workflows/test.yaml"},Object(o.b)("img",{parentName:"a",src:"https://github.com/coderrect-inc/OpenRace/actions/workflows/test.yaml/badge.svg?branch=develop",alt:"build-and-test"}))),Object(o.b)("h1",{id:"running"},"Running"),Object(o.b)("p",null,"Please note, the tool is still in the early stages of development and does not support many features yet."),Object(o.b)("p",null,"Until our first release, the easiest way to run the tool is through the ",Object(o.b)("inlineCode",{parentName:"p"},"coderrect/openrace")," docker image."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-shell"},"> docker pull coderrect/openrace\n> docker run -it --rm coderrect/openrace\n# Now we are inside the docker image\n/OpenRace/examples# make\nclang-10 -S -emit-llvm -g -fopenmp simplethread.c\nopenrace simplethread.ll\n...\n==== Races ====\nsimplethread.c:8:9 simplethread.c:8:9\n          store i32 %inc, i32* @global, align 4, !dbg !53\n          %0 = load i32, i32* @global, align 4, !dbg !53\nsimplethread.c:8:9 simplethread.c:8:9\n          store i32 %inc, i32* @global, align 4, !dbg !53\n          store i32 %inc, i32* @global, align 4, !dbg !53\nTotal Races Detected: 2\n")),Object(o.b)("p",null,"The examples directory contains a few sample files and a Makefile to make running the examples easy."),Object(o.b)("p",null,"To run the OpenRace tool on the ",Object(o.b)("inlineCode",{parentName:"p"},"simplethread.c")," example, just run ",Object(o.b)("inlineCode",{parentName:"p"},"make simplethread"),". This works for any of the samples in the examples directory."),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"coderrect/openrace")," docker image contains all the required tools to build and run the provided examples."),Object(o.b)("h1",{id:"end-to-end-example"},"End-to-End Example"),Object(o.b)("p",null,"This section steps through the process of building an example source file and scanning it with the OpenRace tool."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre"},"// pthread-simple.c\n#include <pthread.h>\n\nint global;\npthread_mutex_t mutex;\nint global_locked;\n\nvoid *foo(void *a) {\n  global++;\n  pthread_mutex_lock(&mutex);\n  global_locked++;\n  pthread_mutex_unlock(&mutex);\n  return 0;\n}\n\nint main() {\n  pthread_t t1, t2;\n  pthread_mutex_t mutex;\n\n  pthread_create(&t1, 0, foo, 0);\n  pthread_create(&t2, 0, foo, 0);\n  pthread_join(t1, 0);\n  pthread_join(t2, 0);\n}\n")),Object(o.b)("p",null,"The OpenRace tool takes LLVM IR as input. Generate the LLVM IR for pthread-simple.c with the following command."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Note"),": Make sure ",Object(o.b)("inlineCode",{parentName:"p"},"clang --version")," shows clang 10.0.x"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre"},"> clang -S -emit-llvm -g pthread-simple.c\n> ls\npthread-simple.c pthread-simple.ll\n")),Object(o.b)("p",null,"Something like ",Object(o.b)("a",{parentName:"p",href:"https://github.com/travitch/whole-program-llvm"},"WLLVM")," can be used to produce an ",Object(o.b)("a",{parentName:"p",href:"https://llvm.org/docs/LangRef.html#abstract"},"LLVM IR")," file for a project with multiple files. "),Object(o.b)("p",null,"Generating LLVM IR for large projects is outside the scope of this tool (for now)."),Object(o.b)("p",null,"Then the .ll file can be passed as input directly to the OpenRace tool."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre"},"> openrace pthread-simple.ll\n==== Races ====\npthreadsimple.c:8:9 pthreadsimple.c:8:9\n          store i32 %inc, i32* @global, align 4, !dbg !53\n          %0 = load i32, i32* @global, align 4, !dbg !53\npthreadsimple.c:8:9 pthreadsimple.c:8:9\n          store i32 %inc, i32* @global, align 4, !dbg !53\n          store i32 %inc, i32* @global, align 4, !dbg !53\nTotal Races Detected: 2\n")))}s.isMDXComponent=!0},92:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return m}));var r=n(0),a=n.n(r);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=a.a.createContext({}),s=function(e){var t=a.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=s(e.components);return a.a.createElement(p.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},u=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=s(n),u=r,m=d["".concat(c,".").concat(u)]||d[u]||b[u]||o;return n?a.a.createElement(m,l(l({ref:t},p),{},{components:n})):a.a.createElement(m,l({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,c=new Array(o);c[0]=u;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l.mdxType="string"==typeof e?e:r,c[1]=l;for(var p=2;p<o;p++)c[p]=n[p];return a.a.createElement.apply(null,c)}return a.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);