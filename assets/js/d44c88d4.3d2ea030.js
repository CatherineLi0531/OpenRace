(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{88:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return p})),n.d(t,"toc",(function(){return i})),n.d(t,"default",(function(){return s}));var a=n(3),r=n(7),l=(n(0),n(93)),o={id:"doc-openmp-support",title:"OpenMP Support"},p={unversionedId:"doc-openmp-support",id:"doc-openmp-support",isDocsHomePage:!1,title:"OpenMP Support",description:"OpenMP Support Summary",source:"@site/docs/doc-openmp-support.md",sourceDirName:".",slug:"/doc-openmp-support",permalink:"/OpenRace/doc-openmp-support",editUrl:"https://github.com/coderrect-inc/OpenRace/tree/develop/website/docs/doc-openmp-support.md",version:"current",frontMatter:{id:"doc-openmp-support",title:"OpenMP Support"},sidebar:"openraceSidebar",previous:{title:"Get Started with Coderrect OpenRace",permalink:"/OpenRace/"},next:{title:"Setting Up Dev Environment",permalink:"/OpenRace/doc-setup-dev-env"}},i=[{value:"OpenMP Support Summary",id:"openmp-support-summary",children:[]},{value:"Remaining OpenMP Features",id:"remaining-openmp-features",children:[{value:"Offloaded OpenMP",id:"offloaded-openmp",children:[]},{value:"OpenMP tasks",id:"openmp-tasks",children:[]},{value:"SIMD",id:"simd",children:[]},{value:"Ordered/Depend",id:"ordereddepend",children:[]},{value:"Array Index Analysis",id:"array-index-analysis",children:[]}]}],c={toc:i};function s(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(l.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)("h2",{id:"openmp-support-summary"},"OpenMP Support Summary"),Object(l.b)("p",null,"Support for OpenMP features is being added and improved over time."),Object(l.b)("p",null,"The table below gives a high level overview of the status on some key features, and detailed descriptions on partially and not supported features are given below."),Object(l.b)("table",null,Object(l.b)("thead",{parentName:"table"},Object(l.b)("tr",{parentName:"thead"},Object(l.b)("th",{parentName:"tr",align:null},"Feature"),Object(l.b)("th",{parentName:"tr",align:null},"Support"),Object(l.b)("th",{parentName:"tr",align:null},"Feature"),Object(l.b)("th",{parentName:"tr",align:null},"Support"))),Object(l.b)("tbody",{parentName:"table"},Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},"omp for loops")),Object(l.b)("td",{parentName:"tr",align:null},"full"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},"threadprivate")),Object(l.b)("td",{parentName:"tr",align:null},"full")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},"barrier")),Object(l.b)("td",{parentName:"tr",align:null},"full"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},"sections")),Object(l.b)("td",{parentName:"tr",align:null},"full")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},"master")),Object(l.b)("td",{parentName:"tr",align:null},"full"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},"offloading")),Object(l.b)("td",{parentName:"tr",align:null},"partial")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},"single")),Object(l.b)("td",{parentName:"tr",align:null},"full"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},"tasks")),Object(l.b)("td",{parentName:"tr",align:null},"partial")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},"reduction")),Object(l.b)("td",{parentName:"tr",align:null},"full"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},"simd")),Object(l.b)("td",{parentName:"tr",align:null},"none")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},"atomic")),Object(l.b)("td",{parentName:"tr",align:null},"full"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},"ordered")),Object(l.b)("td",{parentName:"tr",align:null},"none")),Object(l.b)("tr",{parentName:"tbody"},Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},"critical")),Object(l.b)("td",{parentName:"tr",align:null},"full"),Object(l.b)("td",{parentName:"tr",align:null},Object(l.b)("strong",{parentName:"td"},"depend")),Object(l.b)("td",{parentName:"tr",align:null},"none")))),Object(l.b)("h2",{id:"remaining-openmp-features"},"Remaining OpenMP Features"),Object(l.b)("p",null,"These are features that are not fully supported in OpenRace."),Object(l.b)("h3",{id:"offloaded-openmp"},"Offloaded OpenMP"),Object(l.b)("p",null,"OpenRace has partial support for offloaded OpenMP. Offloaded regions are treated mostly the same as regular OpenMP code, whith a few exceptions."),Object(l.b)("p",null,"When offloaded to a GPU, some OpenMP synchronization features cannot prevent data races to shared memory. These synchronizations are ignored in offloaded regions. Otherwise, the analysis of offloaded regions is treated the same as normal OpenMP parallel regions."),Object(l.b)("h3",{id:"openmp-tasks"},"OpenMP tasks"),Object(l.b)("p",null,"Only the simplest use cases of task is supported so far.\nTask creation and task completion either through barriers or taskwait have been modeled."),Object(l.b)("p",null,"Complex usage (e.g. using taskwait or barriers to synchronize groups of nested tasks) is not supported yet."),Object(l.b)("p",null,"OpenMP tasks also include a number of related features like taskloops, taskgroup, task depend which have yet to be supported in OpenRace."),Object(l.b)("p",null,"The tool may report false positives in cases where complex synchronizations with tasks are used, and false negatives when unsupported task related features are used."),Object(l.b)("h3",{id:"simd"},"SIMD"),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"simd")," directive can be used on its own or in combination with some specific OpenMP features (e.g. ",Object(l.b)("inlineCode",{parentName:"p"},"parallel for simd"),", ",Object(l.b)("inlineCode",{parentName:"p"},"taskloop simd"),", and more)."),Object(l.b)("p",null,"Any usage of ",Object(l.b)("inlineCode",{parentName:"p"},"simd")," is not supported by OpenRace. Any races present in SIMD code will likely be missed."),Object(l.b)("h3",{id:"ordereddepend"},"Ordered/Depend"),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"depend")," clause can be copmbined with various OpenMP features to describe a ordering between different tasks."),Object(l.b)("p",null,"OpenRace has no support for ",Object(l.b)("inlineCode",{parentName:"p"},"depend")," and the described orderings will not be modeled by the tool."),Object(l.b)("p",null,"This will likely lead to false positives in code that uses the ",Object(l.b)("inlineCode",{parentName:"p"},"depend")," clause."),Object(l.b)("h3",{id:"array-index-analysis"},"Array Index Analysis"),Object(l.b)("p",null,"Array Index Analysis is used to determine if any array accesses within a parallel loop may overlap"),Object(l.b)("p",null,"OpenRace currently uses an intra-procedural array index analysis based on LLVM's Scalar Evolution."),Object(l.b)("p",null,"The main limitation of the current implementation is the inability to detect races across function calls."),Object(l.b)("p",null,"The classic example of a race in a parallel loop is shown below."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-c"},"#define N = 100;\nint A[N];\n\n#pragma omp parallel for\nfor (int i = 0; i < N; i++) {\n  A[i] = A[i+1];\n}\n")),Object(l.b)("p",null,"The array index analysis used by OpenRace can detect this race, as all array accesses are made directly inside the parallel loop."),Object(l.b)("p",null,"However, if same code is rewritten such that the accesses happen within a function call, OpenRace's array index analysis is unable to detect the race."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-c"},"int read (int *array, int idx)          { return array[idx]; }\nint write(int *array, int idx, int val) { return array[idx] = val; }\n\n// ...\n\n#pragma omp parallel for\nfor (int i = 0; i < N: i++) {\n  int val = read(A, i+1);\n  write(A, i, val);\n}\n")))}s.isMDXComponent=!0},93:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return m}));var a=n(0),r=n.n(a);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=r.a.createContext({}),s=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):p(p({},t),e)),n},d=function(e){var t=s(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,o=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=s(n),u=a,m=d["".concat(o,".").concat(u)]||d[u]||b[u]||l;return n?r.a.createElement(m,p(p({ref:t},c),{},{components:n})):r.a.createElement(m,p({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,o=new Array(l);o[0]=u;var p={};for(var i in t)hasOwnProperty.call(t,i)&&(p[i]=t[i]);p.originalType=e,p.mdxType="string"==typeof e?e:a,o[1]=p;for(var c=2;c<l;c++)o[c]=n[c];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);